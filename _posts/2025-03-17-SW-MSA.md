---
title: "MSA"
date: 2025-03-15
description: "마이크로서비스 아키텍처"
categories: 
  - Architecture
  - MSA
tags: 
  - MSA
---
# MSA

<aside class="notion_callout">

**MSA(Microservices Architecture, 마이크로서비스 아키텍처)** 는 소프트웨어 개발에서 시스템을 **작고 독립적인 서비스들의 집합**으로 구성하는 아키텍처 스타일이다. 각 서비스는 고유의 기능을 가지고 독립적으로 배포, 확장, 관리 할 수 있다.

</aside>

# MSA의 등장 배경

1. **모놀리식 아키텍처의 한계**

<aside class="notion_callout">

**모놀리식 아키텍처란?** 

하나의 통합된 코드 베이스로 여러 비즈니스 기능을 수행하는 전통적인 아키텍처 스타일이다. 단일 애플리케이션 내에 서비스의 모든 로직이 들어가 있는 구조이다.

</aside>

전통적으로 , 애플리케이션은 모놀리식 구조로 개발 되었는데 이 방식은 하나의 코드베이스로 모든 기능이 밀접하게 결합되어있었음

시간이 지나며 다음과 같은 문제점 발생.

- **복잡성 증가 :** 서비스가 커질수록 코드가 복잡해지고, 작은 기능 수정에도 전체 애플리케이션을 다시 빌드하고 배포
- **유연성 부족 :** 한 부분의 장애가 전체 시스템에 영향을 미침
- **확장성 제한 :** 트래픽이 많은 일부 서비스만 확장하고 싶어도 전체 시스템을 확장해야함
- **기술적 제약** : 특정 기술이나 프레임워크에 종속되어 새로운 기술 도입이 어려움
- **배포 문제** : 하나의 서비스만 수정해도 전체 시스템 배포해야함

1. 대규모 시스템과 빠른 변화 요구
2. 클라우드와 DevOps 문화 확산

---

# **MSA의 핵심 개념**

1. **작고 독립적인 서비스**
    
    각 서비스는 **하나의 기능**이나 도메인에 집중하여 개발된다. 
    
    예: 결제 서비스, 주문 서비스, 사용자 관리 서비스 등.
    
2. **독립적인 배포와 확장**
    
    각 서비스는 **독립적으로 배포 및 확장**할 수 있습니다. 트래픽이 많은 서비스만 별도로 확장 가능하다.
    
3. **분산 데이터 관리**
    
    각 서비스는 자신만의 데이터베이스를 가지고, 다른 서비스의 데이터에 직접 접근하지 않는다. **API**나 **메시지 큐**를 통해 통신합니다.
    
4. **API 기반 통신**
    
    서비스 간 통신은 주로 **HTTP REST API** 또는 **gRPC, 메시지 브로커(Kafka, RabbitMQ 등)**를 통해 이루어진다.
    
5. **자동화된 배포와 모니터링**
    
    CI/CD 파이프라인을 통해 자동으로 빌드, 테스트, 배포하며, 각 서비스의 상태를 독립적으로 모니터링한다.
    

---

### ✅ **MSA의 장점**

1. **유연한 확장성**: 트래픽이 많은 서비스만 선택적으로 확장 가능.
2. **독립적인 배포**: 개별 서비스만 배포해도 되므로 배포 속도 증가.
3. **장애 격리**: 한 서비스의 장애가 전체 시스템에 영향을 주지 않음.
4. **다양한 기술 스택**: 서비스마다 다른 언어, 프레임워크, 데이터베이스 사용 가능.
5. **빠른 개발과 유지보수**: 각 서비스는 작은 단위로 관리되어 개발 및 유지보수가 용이.

---

### ❌ **MSA의 단점**

1. **복잡한 분산 시스템 관리**: 서비스 간 통신, 데이터 일관성, 네트워크 장애 등을 관리해야 함.
2. **배포 복잡성**: 여러 서비스를 각각 배포하고 관리하는 데 복잡성이 증가.
3. **데이터 일관성 문제**: 분산된 데이터베이스로 인해 트랜잭션 관리가 어려움.
4. **서비스 간 통신 비용**: 네트워크 호출로 인한 성능 저하 가능성.
5. **운영 및 모니터링 어려움**: 각 서비스의 상태를 따로 모니터링하고 장애를 감지해야 함.

---

### 🛠️ **MSA에서 사용하는 기술 스택**

| 구분 | 기술 |
| --- | --- |
| **API 통신** | REST, gRPC |
| **메시지 브로커** | Kafka, RabbitMQ, Redis Streams |
| **서비스 디스커버리** | Eureka, Consul, Zookeeper |
| **API Gateway** | Spring Cloud Gateway, Nginx, Kong |
| **컨테이너** | Docker, Kubernetes |
| **CI/CD** | Jenkins, GitHub Actions, GitLab CI |
| **모니터링** | Prometheus, Grafana, ELK Stack |

---

### 🚀 **MSA로 전환 시 고려 사항**

1. **서비스의 경계(Bounded Context)**를 명확히 정의해야 함.
2. **서비스 간 데이터 일관성**을 어떻게 유지할지 고려.
3. **통합 테스트 전략**을 잘 수립해야 함.
4. **분산 트랜잭션**이나 **이벤트 소싱** 같은 복잡한 문제에 대한 대비 필요.
5. **서비스 디스커버리, 로드 밸런싱, 장애 처리**를 자동화.

---

### 💡 **MSA 도입이 적합한 경우**

- 시스템이 복잡하고 빠른 확장과 배포가 필요한 경우.
- 각 서비스가 독립적으로 발전할 수 있는 경우.
- 클라우드 네이티브 환경에서 개발하는 경우.

---

### 🚫 **MSA 도입이 불필요한 경우**

- 작은 규모의 프로젝트로 복잡한 분산 시스템이 필요 없는 경우.
- 유지보수 인력이 부족하고 복잡한 아키텍처가 부담스러운 경우.
- 빠르게 MVP(최소 기능 제품)를 개발해야 하는 경우.
